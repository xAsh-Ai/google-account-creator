#!/usr/bin/env python3\n\"\"\"\n설정 관리 모듈\n\n이 모듈은 Google Account Creator의 설정을 관리합니다.\n- JSON/YAML 설정 파일 로딩\n- 환경 변수 오버라이드\n- 설정 검증 및 기본값\n- 동적 설정 업데이트\n- 설정 암호화 및 보안\n\"\"\"\n\nimport os\nimport json\nimport yaml\nimport logging\nfrom typing import Dict, Any, Optional, List, Union\nfrom dataclasses import dataclass, field, asdict\nfrom pathlib import Path\nfrom datetime import datetime\nimport re\nfrom cryptography.fernet import Fernet\nfrom cryptography.hazmat.primitives import hashes\nfrom cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC\nimport base64\n\n# 로깅 설정\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass DeviceConfig:\n    \"\"\"디바이스 설정 클래스\"\"\"\n    name: str = \"default_device\"\n    platform: str = \"android\"  # android, ios\n    max_workers: int = 2\n    timeout: int = 30\n    capabilities: Dict[str, Any] = field(default_factory=dict)\n    adb_path: Optional[str] = None\n    appium_config: Dict[str, Any] = field(default_factory=dict)\n    proxy_config: Dict[str, Any] = field(default_factory=dict)\n    \n    def __post_init__(self):\n        \"\"\"초기화 후 검증\"\"\"\n        if self.max_workers < 1:\n            self.max_workers = 1\n        if self.timeout < 5:\n            self.timeout = 5\n\n@dataclass\nclass APIConfig:\n    \"\"\"API 설정 클래스\"\"\"\n    # SMS 서비스 설정\n    sms_service: str = \"textverified\"  # textverified, 5sim, etc.\n    sms_api_key: Optional[str] = None\n    sms_rate_limit: int = 10  # per hour\n    \n    # VPN 서비스 설정\n    vpn_service: str = \"nordvpn\"  # nordvpn, expressvpn, etc.\n    vpn_credentials: Dict[str, str] = field(default_factory=dict)\n    vpn_rate_limit: int = 5  # connections per hour\n    \n    # 프록시 설정\n    proxy_service: Optional[str] = None\n    proxy_list: List[str] = field(default_factory=list)\n    proxy_rotation: bool = True\n    \n    # 캡챠 해결 서비스\n    captcha_service: str = \"2captcha\"\n    captcha_api_key: Optional[str] = None\n    \n    def __post_init__(self):\n        \"\"\"초기화 후 검증\"\"\"\n        if self.sms_rate_limit < 1:\n            self.sms_rate_limit = 1\n        if self.vpn_rate_limit < 1:\n            self.vpn_rate_limit = 1\n\n@dataclass\nclass SecurityConfig:\n    \"\"\"보안 설정 클래스\"\"\"\n    encrypt_sensitive_data: bool = True\n    config_encryption_key: Optional[str] = None\n    log_sensitive_data: bool = False\n    secure_storage_path: str = \"./secure_data\"\n    backup_configs: bool = True\n    backup_retention_days: int = 30\n    \n    def __post_init__(self):\n        \"\"\"초기화 후 검증\"\"\"\n        if self.backup_retention_days < 1:\n            self.backup_retention_days = 1\n\n@dataclass\nclass LoggingConfig:\n    \"\"\"로깅 설정 클래스\"\"\"\n    level: str = \"INFO\"\n    file_path: Optional[str] = \"logs/google_account_creator.log\"\n    max_file_size: int = 10 * 1024 * 1024  # 10MB\n    backup_count: int = 5\n    format: str = \"%(asctime)s - %(name)s - %(levelname)s - %(message)s\"\n    console_output: bool = True\n    structured_logging: bool = False\n    \n    def __post_init__(self):\n        \"\"\"초기화 후 검증\"\"\"\n        valid_levels = ['DEBUG', 'INFO', 'WARNING', 'ERROR', 'CRITICAL']\n        if self.level.upper() not in valid_levels:\n            self.level = \"INFO\"\n        if self.max_file_size < 1024:\n            self.max_file_size = 1024\n        if self.backup_count < 1:\n            self.backup_count = 1\n\n@dataclass\nclass PerformanceConfig:\n    \"\"\"성능 설정 클래스\"\"\"\n    target_accounts: int = 10\n    batch_size: int = 5\n    creation_delay: float = 2.0  # seconds between batches\n    max_devices: int = 5\n    max_workers_per_device: int = 2\n    parallel_execution: bool = True\n    \n    # 리소스 제한\n    max_memory_usage_mb: int = 2048\n    max_cpu_usage_percent: int = 80\n    max_network_connections: int = 100\n    \n    # 타임아웃 설정\n    device_timeout: int = 30\n    worker_timeout: int = 300\n    task_timeout: int = 180\n    \n    def __post_init__(self):\n        \"\"\"초기화 후 검증\"\"\"\n        if self.target_accounts < 1:\n            self.target_accounts = 1\n        if self.batch_size < 1:\n            self.batch_size = 1\n        if self.creation_delay < 0:\n            self.creation_delay = 0\n        if self.max_devices < 1:\n            self.max_devices = 1\n        if self.max_workers_per_device < 1:\n            self.max_workers_per_device = 1\n\n@dataclass\nclass AppConfig:\n    \"\"\"메인 애플리케이션 설정 클래스\"\"\"\n    # 기본 설정\n    version: str = \"1.0.0\"\n    debug: bool = False\n    \n    # 하위 설정 그룹\n    performance: PerformanceConfig = field(default_factory=PerformanceConfig)\n    api: APIConfig = field(default_factory=APIConfig)\n    security: SecurityConfig = field(default_factory=SecurityConfig)\n    logging: LoggingConfig = field(default_factory=LoggingConfig)\n    devices: List[DeviceConfig] = field(default_factory=list)\n    \n    # 호환성 속성 (기존 코드와의 호환성)\n    @property\n    def target_accounts(self) -> int:\n        return self.performance.target_accounts\n    \n    @target_accounts.setter\n    def target_accounts(self, value: int):\n        self.performance.target_accounts = value\n    \n    @property\n    def batch_size(self) -> int:\n        return self.performance.batch_size\n    \n    @batch_size.setter\n    def batch_size(self, value: int):\n        self.performance.batch_size = value\n    \n    @property\n    def creation_delay(self) -> float:\n        return self.performance.creation_delay\n    \n    @creation_delay.setter\n    def creation_delay(self, value: float):\n        self.performance.creation_delay = value\n    \n    @property\n    def max_devices(self) -> int:\n        return self.performance.max_devices\n    \n    @max_devices.setter\n    def max_devices(self, value: int):\n        self.performance.max_devices = value\n    \n    @property\n    def max_workers_per_device(self) -> int:\n        return self.performance.max_workers_per_device\n    \n    @max_workers_per_device.setter\n    def max_workers_per_device(self, value: int):\n        self.performance.max_workers_per_device = value\n    \n    @property\n    def device_timeout(self) -> int:\n        return self.performance.device_timeout\n    \n    @device_timeout.setter\n    def device_timeout(self, value: int):\n        self.performance.device_timeout = value\n    \n    @property\n    def log_level(self) -> str:\n        return self.logging.level\n    \n    @log_level.setter\n    def log_level(self, value: str):\n        self.logging.level = value\n    \n    @property\n    def log_file(self) -> Optional[str]:\n        return self.logging.file_path\n    \n    @log_file.setter\n    def log_file(self, value: Optional[str]):\n        self.logging.file_path = value\n    \n    # 추가 편의 속성\n    @property\n    def max_api_calls_per_hour(self) -> int:\n        return self.api.sms_rate_limit\n    \n    @max_api_calls_per_hour.setter\n    def max_api_calls_per_hour(self, value: int):\n        self.api.sms_rate_limit = value\n    \n    @property\n    def max_vpn_connections(self) -> int:\n        return self.api.vpn_rate_limit\n    \n    @max_vpn_connections.setter\n    def max_vpn_connections(self, value: int):\n        self.api.vpn_rate_limit = value\n    \n    def validate(self) -> List[str]:\n        \"\"\"설정 검증 및 오류 목록 반환\"\"\"\n        errors = []\n        \n        # 성능 설정 검증\n        if self.performance.target_accounts > 1000:\n            errors.append(\"target_accounts는 1000개를 초과할 수 없습니다.\")\n        \n        if self.performance.batch_size > self.performance.target_accounts:\n            errors.append(\"batch_size는 target_accounts보다 클 수 없습니다.\")\n        \n        # API 키 검증\n        if not self.api.sms_api_key:\n            errors.append(\"SMS API 키가 설정되지 않았습니다.\")\n        \n        # 디바이스 설정 검증\n        if not self.devices:\n            logger.warning(\"디바이스 설정이 없습니다. 자동 검색을 사용합니다.\")\n        \n        # 보안 설정 검증\n        if self.security.encrypt_sensitive_data and not self.security.config_encryption_key:\n            errors.append(\"암호화가 활성화되었지만 암호화 키가 설정되지 않았습니다.\")\n        \n        return errors\n\nclass ConfigManager:\n    \"\"\"설정 관리자 클래스\"\"\"\n    \n    def __init__(self, config_path: Optional[str] = None):\n        \"\"\"\n        설정 관리자 초기화\n        \n        Args:\n            config_path: 설정 파일 경로\n        \"\"\"\n        self.config_path = config_path or \"config.json\"\n        self.config: Optional[AppConfig] = None\n        self.encryption_key: Optional[bytes] = None\n        \n        # 환경 변수 매핑\n        self.env_mappings = {\n            \"GAC_TARGET_ACCOUNTS\": \"performance.target_accounts\",\n            \"GAC_BATCH_SIZE\": \"performance.batch_size\",\n            \"GAC_CREATION_DELAY\": \"performance.creation_delay\",\n            \"GAC_MAX_DEVICES\": \"performance.max_devices\",\n            \"GAC_LOG_LEVEL\": \"logging.level\",\n            \"GAC_LOG_FILE\": \"logging.file_path\",\n            \"GAC_DEBUG\": \"debug\",\n            \"GAC_SMS_API_KEY\": \"api.sms_api_key\",\n            \"GAC_CAPTCHA_API_KEY\": \"api.captcha_api_key\",\n            \"GAC_VPN_SERVICE\": \"api.vpn_service\",\n            \"GAC_SMS_SERVICE\": \"api.sms_service\",\n        }\n        \n        logger.info(f\"설정 관리자가 초기화되었습니다: {self.config_path}\")\n    \n    def load_config(self, config_path: Optional[str] = None) -> AppConfig:\n        \"\"\"\n        설정 파일을 로드합니다.\n        \n        Args:\n            config_path: 설정 파일 경로\n            \n        Returns:\n            로드된 설정\n        \"\"\"\n        if config_path:\n            self.config_path = config_path\n        \n        logger.info(f\"설정 파일 로드 중: {self.config_path}\")\n        \n        # 기본 설정으로 시작\n        self.config = AppConfig()\n        \n        # 설정 파일이 존재하면 로드\n        config_file = Path(self.config_path)\n        if config_file.exists():\n            try:\n                if config_file.suffix.lower() in ['.yaml', '.yml']:\n                    self.config = self._load_yaml_config(config_file)\n                else:\n                    self.config = self._load_json_config(config_file)\n                \n                logger.info(\"설정 파일 로드 완료\")\n            except Exception as e:\n                logger.error(f\"설정 파일 로드 실패: {e}\")\n                logger.info(\"기본 설정을 사용합니다.\")\n        else:\n            logger.info(f\"설정 파일이 없습니다: {self.config_path}\")\n            logger.info(\"기본 설정을 사용하고 새 설정 파일을 생성합니다.\")\n            self.save_config()\n        \n        # 환경 변수 오버라이드 적용\n        self._apply_env_overrides()\n        \n        # 설정 검증\n        validation_errors = self.config.validate()\n        if validation_errors:\n            logger.warning(\"설정 검증 경고:\")\n            for error in validation_errors:\n                logger.warning(f\"  - {error}\")\n        \n        return self.config\n    \n    def _load_json_config(self, config_file: Path) -> AppConfig:\n        \"\"\"JSON 설정 파일을 로드합니다.\"\"\"\n        with open(config_file, 'r', encoding='utf-8') as f:\n            config_data = json.load(f)\n        \n        return self._dict_to_config(config_data)\n    \n    def _load_yaml_config(self, config_file: Path) -> AppConfig:\n        \"\"\"YAML 설정 파일을 로드합니다.\"\"\"\n        with open(config_file, 'r', encoding='utf-8') as f:\n            config_data = yaml.safe_load(f)\n        \n        return self._dict_to_config(config_data)\n    \n    def _dict_to_config(self, config_data: Dict[str, Any]) -> AppConfig:\n        \"\"\"딕셔너리를 AppConfig 객체로 변환합니다.\"\"\"\n        # 중첩된 딕셔너리를 데이터클래스로 변환\n        if 'performance' in config_data:\n            config_data['performance'] = PerformanceConfig(**config_data['performance'])\n        \n        if 'api' in config_data:\n            config_data['api'] = APIConfig(**config_data['api'])\n        \n        if 'security' in config_data:\n            config_data['security'] = SecurityConfig(**config_data['security'])\n        \n        if 'logging' in config_data:\n            config_data['logging'] = LoggingConfig(**config_data['logging'])\n        \n        if 'devices' in config_data:\n            config_data['devices'] = [\n                DeviceConfig(**device) for device in config_data['devices']\n            ]\n        \n        return AppConfig(**config_data)\n    \n    def _apply_env_overrides(self):\n        \"\"\"환경 변수로 설정을 오버라이드합니다.\"\"\"\n        applied_overrides = []\n        \n        for env_var, config_path in self.env_mappings.items():\n            env_value = os.getenv(env_var)\n            if env_value is not None:\n                try:\n                    self._set_nested_config(config_path, env_value)\n                    applied_overrides.append(f\"{env_var} -> {config_path}\")\n                except Exception as e:\n                    logger.error(f\"환경 변수 {env_var} 적용 실패: {e}\")\n        \n        if applied_overrides:\n            logger.info(f\"환경 변수 오버라이드 적용: {len(applied_overrides)}개\")\n            for override in applied_overrides:\n                logger.debug(f\"  - {override}\")\n    \n    def _set_nested_config(self, config_path: str, value: str):\n        \"\"\"중첩된 설정 경로에 값을 설정합니다.\"\"\"\n        parts = config_path.split('.')\n        current = self.config\n        \n        # 마지막 키를 제외하고 탐색\n        for part in parts[:-1]:\n            current = getattr(current, part)\n        \n        # 값 타입 변환\n        final_key = parts[-1]\n        current_value = getattr(current, final_key)\n        \n        if isinstance(current_value, bool):\n            value = value.lower() in ('true', '1', 'yes', 'on')\n        elif isinstance(current_value, int):\n            value = int(value)\n        elif isinstance(current_value, float):\n            value = float(value)\n        # str은 그대로 사용\n        \n        setattr(current, final_key, value)\n    \n    def save_config(self, config_path: Optional[str] = None) -> bool:\n        \"\"\"\n        설정을 파일에 저장합니다.\n        \n        Args:\n            config_path: 저장할 파일 경로\n            \n        Returns:\n            저장 성공 여부\n        \"\"\"\n        if config_path:\n            self.config_path = config_path\n        \n        if not self.config:\n            logger.error(\"저장할 설정이 없습니다.\")\n            return False\n        \n        try:\n            # 설정을 딕셔너리로 변환\n            config_dict = asdict(self.config)\n            \n            # 민감한 데이터 암호화 (필요한 경우)\n            if self.config.security.encrypt_sensitive_data:\n                config_dict = self._encrypt_sensitive_data(config_dict)\n            \n            # 파일 확장자에 따라 저장 형식 결정\n            config_file = Path(self.config_path)\n            config_file.parent.mkdir(parents=True, exist_ok=True)\n            \n            if config_file.suffix.lower() in ['.yaml', '.yml']:\n                with open(config_file, 'w', encoding='utf-8') as f:\n                    yaml.dump(config_dict, f, default_flow_style=False, allow_unicode=True)\n            else:\n                with open(config_file, 'w', encoding='utf-8') as f:\n                    json.dump(config_dict, f, indent=2, ensure_ascii=False)\n            \n            logger.info(f\"설정 파일 저장 완료: {self.config_path}\")\n            return True\n            \n        except Exception as e:\n            logger.error(f\"설정 파일 저장 실패: {e}\")\n            return False\n    \n    def _encrypt_sensitive_data(self, config_dict: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"민감한 데이터를 암호화합니다.\"\"\"\n        if not self.encryption_key:\n            self._initialize_encryption()\n        \n        # 암호화할 필드들\n        sensitive_fields = [\n            ['api', 'sms_api_key'],\n            ['api', 'captcha_api_key'],\n            ['api', 'vpn_credentials'],\n        ]\n        \n        for field_path in sensitive_fields:\n            try:\n                current = config_dict\n                for key in field_path[:-1]:\n                    current = current.get(key, {})\n                \n                final_key = field_path[-1]\n                if final_key in current and current[final_key]:\n                    # 암호화\n                    fernet = Fernet(self.encryption_key)\n                    encrypted_value = fernet.encrypt(str(current[final_key]).encode())\n                    current[final_key] = base64.b64encode(encrypted_value).decode()\n                    \n            except Exception as e:\n                logger.error(f\"필드 {'.'.join(field_path)} 암호화 실패: {e}\")\n        \n        return config_dict\n    \n    def _initialize_encryption(self):\n        \"\"\"암호화 키를 초기화합니다.\"\"\"\n        password = self.config.security.config_encryption_key or \"default_password\"\n        salt = b'salt_1234567890'  # 실제로는 더 안전한 방법으로 생성\n        \n        kdf = PBKDF2HMAC(\n            algorithm=hashes.SHA256(),\n            length=32,\n            salt=salt,\n            iterations=100000,\n        )\n        \n        key = base64.urlsafe_b64encode(kdf.derive(password.encode()))\n        self.encryption_key = key\n    \n    def update_config(self, updates: Dict[str, Any]) -> bool:\n        \"\"\"\n        설정을 동적으로 업데이트합니다.\n        \n        Args:\n            updates: 업데이트할 설정 딕셔너리\n            \n        Returns:\n            업데이트 성공 여부\n        \"\"\"\n        if not self.config:\n            logger.error(\"설정이 로드되지 않았습니다.\")\n            return False\n        \n        try:\n            for key, value in updates.items():\n                if '.' in key:\n                    # 중첩된 키 처리\n                    self._set_nested_config(key, str(value))\n                else:\n                    # 단순 키 처리\n                    if hasattr(self.config, key):\n                        setattr(self.config, key, value)\n                    else:\n                        logger.warning(f\"알 수 없는 설정 키: {key}\")\n            \n            logger.info(f\"설정 업데이트 완료: {len(updates)}개 항목\")\n            return True\n            \n        except Exception as e:\n            logger.error(f\"설정 업데이트 실패: {e}\")\n            return False\n    \n    def get_config_summary(self) -> Dict[str, Any]:\n        \"\"\"설정 요약을 반환합니다.\"\"\"\n        if not self.config:\n            return {}\n        \n        return {\n            \"version\": self.config.version,\n            \"target_accounts\": self.config.target_accounts,\n            \"max_devices\": self.config.max_devices,\n            \"max_workers_per_device\": self.config.max_workers_per_device,\n            \"batch_size\": self.config.batch_size,\n            \"log_level\": self.config.log_level,\n            \"sms_service\": self.config.api.sms_service,\n            \"vpn_service\": self.config.api.vpn_service,\n            \"devices_configured\": len(self.config.devices),\n            \"encryption_enabled\": self.config.security.encrypt_sensitive_data\n        }\n    \n    def create_backup(self) -> bool:\n        \"\"\"설정 파일의 백업을 생성합니다.\"\"\"\n        if not Path(self.config_path).exists():\n            logger.warning(\"백업할 설정 파일이 없습니다.\")\n            return False\n        \n        try:\n            backup_dir = Path(\"backups/config\")\n            backup_dir.mkdir(parents=True, exist_ok=True)\n            \n            timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n            backup_file = backup_dir / f\"config_backup_{timestamp}.json\"\n            \n            # 원본 파일 복사\n            import shutil\n            shutil.copy2(self.config_path, backup_file)\n            \n            logger.info(f\"설정 백업 생성: {backup_file}\")\n            \n            # 오래된 백업 정리\n            self._cleanup_old_backups(backup_dir)\n            \n            return True\n            \n        except Exception as e:\n            logger.error(f\"설정 백업 생성 실패: {e}\")\n            return False\n    \n    def _cleanup_old_backups(self, backup_dir: Path):\n        \"\"\"오래된 백업 파일을 정리합니다.\"\"\"\n        try:\n            retention_days = self.config.security.backup_retention_days\n            cutoff_time = datetime.now().timestamp() - (retention_days * 24 * 3600)\n            \n            for backup_file in backup_dir.glob(\"config_backup_*.json\"):\n                if backup_file.stat().st_mtime < cutoff_time:\n                    backup_file.unlink()\n                    logger.debug(f\"오래된 백업 삭제: {backup_file}\")\n                    \n        except Exception as e:\n            logger.error(f\"백업 정리 실패: {e}\")\n\n# 전역 설정 관리자 인스턴스\n_config_manager: Optional[ConfigManager] = None\n\ndef get_config_manager() -> ConfigManager:\n    \"\"\"전역 설정 관리자 인스턴스를 반환합니다.\"\"\"\n    global _config_manager\n    if _config_manager is None:\n        _config_manager = ConfigManager()\n    return _config_manager\n\ndef load_config(config_path: Optional[str] = None) -> AppConfig:\n    \"\"\"설정을 로드합니다.\"\"\"\n    manager = get_config_manager()\n    return manager.load_config(config_path)\n\ndef save_config(config: AppConfig, config_path: Optional[str] = None) -> bool:\n    \"\"\"설정을 저장합니다.\"\"\"\n    manager = get_config_manager()\n    manager.config = config\n    return manager.save_config(config_path)\n\ndef create_default_config() -> AppConfig:\n    \"\"\"기본 설정을 생성합니다.\"\"\"\n    config = AppConfig()\n    \n    # 기본 디바이스 설정 추가\n    default_device = DeviceConfig(\n        name=\"default_android\",\n        platform=\"android\",\n        max_workers=2,\n        timeout=30\n    )\n    config.devices.append(default_device)\n    \n    logger.info(\"기본 설정이 생성되었습니다.\")\n    return config\n\nif __name__ == \"__main__\":\n    # 테스트 코드\n    logging.basicConfig(level=logging.INFO)\n    \n    # 설정 관리자 테스트\n    config_manager = ConfigManager(\"test_config.json\")\n    config = config_manager.load_config()\n    \n    print(\"설정 요약:\")\n    summary = config_manager.get_config_summary()\n    for key, value in summary.items():\n        print(f\"  {key}: {value}\")\n    \n    # 설정 업데이트 테스트\n    config_manager.update_config({\n        \"performance.target_accounts\": 20,\n        \"logging.level\": \"DEBUG\"\n    })\n    \n    # 백업 생성\n    config_manager.create_backup()\n    \n    print(\"설정 관리 테스트 완료!\") 